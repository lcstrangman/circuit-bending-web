<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Organic Circuit Bender</title>
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #ddd; padding: 20px; display: flex; flex-direction: column; align-items: center; margin: 0; }
        .control-panel { background: #151515; padding: 20px; border: 1px solid #333; border-radius: 8px; margin-bottom: 20px; width: 100%; max-width: 900px; display: flex; justify-content: space-between; align-items: center; box-sizing: border-box; flex-wrap: wrap; gap: 15px;}
        .panel-group { display: flex; align-items: center; gap: 10px; }
        input[type="number"] { background: #000; color: #fff; border: 1px solid #555; padding: 8px; font-family: monospace; font-size: 16px; width: 120px; text-align: center;}
        button { background: #333; color: #fff; border: 1px solid #555; padding: 10px 15px; font-weight: bold; cursor: pointer; font-family: monospace; font-size: 14px; transition: 0.2s; border-radius: 4px;}
        button:hover { background: #555; border-color: #888; }
        .btn-primary { background: #5a2e98; border-color: #7b4ec2; }
        .btn-primary:hover { background: #7b4ec2; border-color: #9d70e6; }
        canvas { max-width: 100%; border: 1px solid #222; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8); }
        #status { font-size: 12px; color: #888; }
    </style>
</head>
<body>

    <div class="control-panel">
        <div class="panel-group">
            <input type="file" id="imageLoader" accept="image/*,.dng,.cr2,.nef,.arw" style="display: none;"/>
            <button onclick="document.getElementById('imageLoader').click()">Load Image</button>
            <span id="status">Waiting for feed...</span>
        </div>
        
        <div class="panel-group">
            <button onclick="goBack()" id="btnBack" disabled>◄</button>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <label style="font-size: 10px; color: #888; margin-bottom: 4px;">MASTER SEED</label>
                <input type="number" id="seedInput" value="1337">
            </div>
            <button onclick="goForward()" id="btnForward" disabled>►</button>
            <button class="btn-primary" onclick="rollNewSeed()">Reroll (Space)</button>
        </div>

        <div class="panel-group">
            <button onclick="exportImage()">Export Frame</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const seedInput = document.getElementById('seedInput');
        let originalImageData = null;
        let imageHash = 0; 

        // --- HISTORY MANAGEMENT ---
        let seedHistory = [];
        let historyIndex = -1;

        function updateHistoryButtons() {
            document.getElementById('btnBack').disabled = historyIndex <= 0;
            document.getElementById('btnForward').disabled = historyIndex >= seedHistory.length - 1;
        }

        function rollNewSeed() {
            if (!originalImageData) return;
            const newSeed = Math.floor(Math.random() * 9999999) + 1;
            seedHistory = seedHistory.slice(0, historyIndex + 1);
            seedHistory.push(newSeed);
            historyIndex++;
            seedInput.value = newSeed;
            updateHistoryButtons();
            executeGlitchPipeline();
        }

        function goBack() {
            if (historyIndex > 0) {
                historyIndex--;
                seedInput.value = seedHistory[historyIndex];
                updateHistoryButtons();
                executeGlitchPipeline();
            }
        }

        function goForward() {
            if (historyIndex < seedHistory.length - 1) {
                historyIndex++;
                seedInput.value = seedHistory[historyIndex];
                updateHistoryButtons();
                executeGlitchPipeline();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target !== seedInput) {
                e.preventDefault();
                rollNewSeed();
            }
        });

        // --- PRNG ---
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function generateImageHash(imageData) {
            const data = imageData.data;
            let hash = 0;
            const step = Math.floor(data.length / 400);
            for (let i = 0; i < data.length; i += step * 4) {
                hash = ((hash << 5) - hash) + data[i] + data[i+1] + data[i+2];
                hash = hash & hash;
            }
            hash ^= imageData.width * imageData.height;
            return Math.abs(hash);
        }

        // --- FILE HANDLING & EXPORT ---
        document.getElementById('imageLoader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('status').innerText = "Processing buffer...";
            
            const formData = new FormData();
            formData.append('file', file);

            try {
                const res = await fetch('/upload', { method: 'POST', body: formData });
                const blob = await res.blob();
                
                const img = new Image();
                img.onload = () => {
                    const scale = Math.min(1, 1400 / img.width); 
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    imageHash = generateImageHash(originalImageData);
                    document.getElementById('status').innerText = "Signal Locked.";
                    rollNewSeed();
                };
                img.src = URL.createObjectURL(blob);
            } catch (err) {
                document.getElementById('status').innerText = "Upload failed.";
            }
        });

        function exportImage() {
            if (!originalImageData) return;
            const currentSeed = seedInput.value;
            const link = document.createElement('a');
            link.download = `leostrangman_glitch_${currentSeed}.png`; 
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        seedInput.addEventListener('change', executeGlitchPipeline);

        // --- THE NEW GENERATIVE PIPELINE ---
        function executeGlitchPipeline() {
            if (!originalImageData) return;
            
            const seed = parseInt(seedInput.value);
            const imageSeed = seed ^ imageHash;
            const rng = mulberry32(imageSeed);

            const width = canvas.width;
            const height = canvas.height;
            const newImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), width, height);
            const data = newImageData.data;

            // --- MODULE 1: DEEP PALETTE MAPPING (Fleshed out colors) ---
            // Instead of just multiplying channels, we wildly shift the color space
            if (rng() > 0.2) { 
                const rBoost = rng() * 1.5 + 0.5;
                const gBoost = rng() * 1.5 + 0.5;
                const bBoost = rng() * 1.5 + 0.5;
                const invertChannel = rng() > 0.7 ? Math.floor(rng() * 3) : -1;

                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i] * rBoost;
                    let g = data[i+1] * gBoost;
                    let b = data[i+2] * bBoost;

                    // Randomly invert one color channel for that toxic/acid look
                    if (invertChannel === 0) r = 255 - r;
                    if (invertChannel === 1) g = 255 - g;
                    if (invertChannel === 2) b = 255 - b;

                    data[i] = Math.min(255, Math.max(0, r));
                    data[i+1] = Math.min(255, Math.max(0, g));
                    data[i+2] = Math.min(255, Math.max(0, b));
                }
            }

            // --- MODULE 2: VRAM BLOCK SPLITTING (Weird Splitting) ---
            // Grabs random chunks of the image and violently shifts them
            const numBlocks = Math.floor(rng() * 15) + 5;
            const tempData = new Uint8ClampedArray(data);
            
            for (let b = 0; b < numBlocks; b++) {
                const bWidth = Math.floor(rng() * (width * 0.4)) + 50;
                const bHeight = Math.floor(rng() * (height * 0.2)) + 20;
                const startX = Math.floor(rng() * width);
                const startY = Math.floor(rng() * height);
                
                // How far this block gets thrown
                const shiftX = Math.floor((rng() * 100) - 50);
                const shiftY = rng() > 0.8 ? Math.floor((rng() * 40) - 20) : 0; // Occasional vertical tear

                for (let y = 0; y < bHeight; y++) {
                    for (let x = 0; x < bWidth; x++) {
                        const destY = (startY + y) % height;
                        const destX = (startX + x) % width;
                        const destI = (destY * width + destX) * 4;

                        let srcX = (destX - shiftX + width) % width;
                        let srcY = (destY - shiftY + height) % height;
                        const srcI = (srcY * width + srcX) * 4;

                        data[destI] = tempData[srcI];
                        data[destI+1] = tempData[srcI+1];
                        data[destI+2] = tempData[srcI+2];
                    }
                }
            }

            // --- MODULE 3: SECTIONAL COLOR SEPARATION ---
            // Rips the RGB channels apart, but ONLY inside specific zones
            const numZones = Math.floor(rng() * 6) + 2;
            const tempSepData = new Uint8ClampedArray(data);

            for (let z = 0; z < numZones; z++) {
                const zStartY = Math.floor(rng() * height);
                const zHeight = Math.floor(rng() * 150) + 50;
                const rShift = Math.floor((rng() * 40) - 20);
                const bShift = Math.floor((rng() * 40) - 20);

                for (let y = zStartY; y < Math.min(zStartY + zHeight, height); y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        let srcXr = (x + rShift + width) % width;
                        let srcXb = (x + bShift + width) % width;
                        
                        data[i] = tempSepData[(y * width + srcXr) * 4];       // Red
                        // Green stays locked in place
                        data[i+2] = tempSepData[(y * width + srcXb) * 4 + 2]; // Blue
                    }
                }
            }

            // --- MODULE 4: INTERVAL PIXEL SORTING (The "Melt") ---
            // Finds high-contrast pixels and drags them down with a decay
            if (rng() > 0.2) {
                const threshold = rng() * 100 + 100; // How bright a pixel needs to be to melt
                const maxDroop = Math.floor(rng() * 150) + 50;
                
                for (let x = 0; x < width; x++) {
                    let isDrooping = false;
                    let droopLife = 0;
                    let dR, dG, dB;

                    for (let y = 0; y < height; y++) {
                        const i = (y * width + x) * 4;
                        const luma = data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;

                        // Start a new melt if the pixel crosses the threshold
                        if (!isDrooping && rng() < 0.05 && luma > threshold) {
                            isDrooping = true;
                            dR = data[i]; dG = data[i+1]; dB = data[i+2];
                            droopLife = Math.floor(rng() * maxDroop);
                        }

                        if (isDrooping) {
                            // Blend the drooping pixel over the actual image data
                            // This creates the "shattered glass" / dirty melt look
                            const blend = droopLife / maxDroop; 
                            data[i] = (data[i] * (1 - blend)) + (dR * blend);
                            data[i+1] = (data[i+1] * (1 - blend)) + (dG * blend);
                            data[i+2] = (data[i+2] * (1 - blend)) + (dB * blend);
                            
                            droopLife--;
                            if (droopLife <= 0) isDrooping = false;
                        }
                    }
                }
            }

            // --- MODULE 5: HARSH BAYER DITHERING ---
            // We crush the color palette heavily so the dither dots become highly visible
            if (rng() > 0.4) {
                const bayerMatrix = [
                    [ 0,  8,  2, 10],
                    [12,  4, 14,  6],
                    [ 3, 11,  1,  9],
                    [15,  7, 13,  5]
                ];
                
                // How aggressive the palette crunch is (lower = more crushed)
                const colorSteps = Math.floor(rng() * 4) + 2; 
                const ditherSpread = rng() * 40 + 20;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        
                        // Get the Bayer threshold for this specific pixel
                        const threshold = (bayerMatrix[y % 4][x % 4] / 16.0 - 0.5) * ditherSpread;

                        // Apply threshold, crush to steps, and snap back to 0-255
                        data[i]   = Math.floor(Math.min(255, Math.max(0, data[i]   + threshold)) / 255 * colorSteps) * (255 / colorSteps);
                        data[i+1] = Math.floor(Math.min(255, Math.max(0, data[i+1] + threshold)) / 255 * colorSteps) * (255 / colorSteps);
                        data[i+2] = Math.floor(Math.min(255, Math.max(0, data[i+2] + threshold)) / 255 * colorSteps) * (255 / colorSteps);
                    }
                }
            }

            ctx.putImageData(newImageData, 0, 0);
        }
    </script>
</body>
</html>