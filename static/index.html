<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generative Circuit Bender</title>
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #0f0; padding: 20px; display: flex; flex-direction: column; align-items: center; margin: 0; }
        .control-panel { background: #1a1a1a; padding: 20px; border: 2px solid #333; border-radius: 5px; margin-bottom: 20px; width: 100%; max-width: 800px; display: flex; justify-content: space-between; align-items: center; box-sizing: border-box;}
        .panel-group { display: flex; flex-direction: column; gap: 10px; }
        input[type="number"] { background: #000; color: #0f0; border: 1px solid #0f0; padding: 8px; font-family: monospace; font-size: 16px; width: 150px;}
        button { background: #0f0; color: #000; border: none; padding: 10px 20px; font-weight: bold; cursor: pointer; font-family: monospace; font-size: 14px; transition: 0.2s;}
        button:hover { background: #afa; }
        .btn-outline { background: transparent; color: #0f0; border: 1px solid #0f0; }
        .btn-outline:hover { background: #0f0; color: #000; }
        canvas { max-width: 100%; border: 1px solid #333; box-shadow: 0 0 20px rgba(0, 255, 0, 0.1); }
    </style>
</head>
<body>

    <div class="control-panel">
        <div class="panel-group">
            <input type="file" id="imageLoader" accept="image/*,.dng,.cr2" style="display: none;"/>
            <button class="btn-outline" onclick="document.getElementById('imageLoader').click()">1. Load RAW Image</button>
            <span id="status">Waiting for image...</span>
        </div>
        
        <div class="panel-group" style="align-items: flex-end;">
            <div>
                <label>Master Seed: </label>
                <input type="number" id="seedInput" value="1337">
            </div>
            <button onclick="generateRandomSeed()">2. Reroll Hardware Failure</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const seedInput = document.getElementById('seedInput');
        let originalImageData = null;

        // --- 1. THE PRNG (Pseudo-Random Number Generator) ---
        // This ensures the Math.random() equivalent is locked to our seed.
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // --- 2. FILE HANDLING ---
        document.getElementById('imageLoader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('status').innerText = "Developing...";
            
            const formData = new FormData();
            formData.append('file', file);

            try {
                const res = await fetch('/upload', { method: 'POST', body: formData });
                const blob = await res.blob();
                
                const img = new Image();
                img.onload = () => {
                    const scale = Math.min(1, 1200 / img.width); // Scale for performance
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    document.getElementById('status').innerText = "Signal Locked.";
                    
                    generateRandomSeed(); // Auto-glitch on load
                };
                img.src = URL.createObjectURL(blob);
            } catch (err) {
                document.getElementById('status').innerText = "Upload failed.";
            }
        });

        function generateRandomSeed() {
            if (!originalImageData) return;
            // Generate a random number between 1 and 9999999
            const newSeed = Math.floor(Math.random() * 9999999) + 1;
            seedInput.value = newSeed;
            executeGlitchPipeline();
        }

        // Listen for manual seed changes
        seedInput.addEventListener('change', executeGlitchPipeline);

        // --- 3. THE GENERATIVE PIPELINE ---
        function executeGlitchPipeline() {
            if (!originalImageData) return;
            
            // Initialize our predictable random number generator with the seed
            const seed = parseInt(seedInput.value);
            const rng = mulberry32(seed);

            const width = canvas.width;
            const height = canvas.height;
            
            // Create a fresh copy of the clean image data to destroy
            const newImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                width,
                height
            );
            const data = newImageData.data;

            // --- MODULE A: DEEP PALETTE SHIFT (FALSE COLOR) ---
            // The seed decides if we shift colors, and exactly what binary key to use.
            if (rng() > 0.4) { // 60% chance to happen
                const rKey = Math.floor(rng() * 100);
                const gKey = Math.floor(rng() * 100);
                const bKey = Math.floor(rng() * 100);
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] ^= rKey;
                    data[i+1] ^= gKey;
                    data[i+2] ^= bKey;
                }
            }

            // --- MODULE B: HARDWARE SYNC BARS ---
            // Generates thick or thin horizontal lines that shift data
            if (rng() > 0.2) { // 80% chance
                const barFreq = Math.floor(rng() * 50) + 10;
                const barThickness = Math.floor(rng() * 10) + 2;
                const shiftAmount = Math.floor((rng() * 60) - 30); // Can shift left or right

                for (let y = 0; y < height; y++) {
                    if (y % barFreq < barThickness) {
                        for (let x = 0; x < width; x++) {
                            const i = (y * width + x) * 4;
                            
                            // Wrap pixels around the screen edges
                            let srcX = (x - shiftAmount) % width;
                            if (srcX < 0) srcX += width;
                            const srcI = (y * width + srcX) * 4;

                            data[i] = originalImageData.data[srcI];
                            data[i+1] = originalImageData.data[srcI+1];
                            data[i+2] = originalImageData.data[srcI+2];
                            
                            // Optionally invert the colors inside the bar for contrast
                            if (rng() > 0.95) { 
                                data[i] = 255 - data[i];
                                data[i+1] = 255 - data[i+1];
                                data[i+2] = 255 - data[i+2];
                            }
                        }
                    }
                }
            }

            // --- MODULE C: DATA DROOP (VERTICAL SMEAR & NOISE) ---
            // Scans down columns. Bright pixels trigger a downward melt.
            if (rng() > 0.1) { // 90% chance
                const threshold = rng() * 0.4 + 0.4; // How bright a pixel needs to be to melt
                const maxDroop = Math.floor(rng() * 200) + 50; // How far it drags down

                for (let x = 0; x < width; x++) {
                    let isDrooping = false;
                    let droopColor = [0, 0, 0];
                    let droopRemaining = 0;

                    for (let y = 0; y < height; y++) {
                        const i = (y * width + x) * 4;

                        if (isDrooping) {
                            // Smear the pixel downward, adding harsh noise to it
                            data[i] = droopColor[0] + (rng() * 80 - 40);
                            data[i+1] = droopColor[1] + (rng() * 80 - 40);
                            data[i+2] = droopColor[2] + (rng() * 80 - 40);
                            droopRemaining--;
                            if (droopRemaining <= 0) isDrooping = false;
                        } else {
                            // Check luminance to see if we should start a new droop
                            const luma = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114) / 255;
                            // Small chance to trigger IF the pixel is bright enough
                            if (rng() < 0.05 && luma > threshold) {
                                isDrooping = true;
                                droopRemaining = Math.floor(rng() * maxDroop) + 10;
                                droopColor = [data[i], data[i+1], data[i+2]];
                            }
                        }
                    }
                }
            }

            // Push the final glitched data to the canvas
            ctx.putImageData(newImageData, 0, 0);
        }
    </script>
</body>
</html>